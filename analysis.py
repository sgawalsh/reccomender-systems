# -*- coding: utf-8 -*-

import pickle
import numpy as np
from scipy.spatial import cKDTree
import data
import sgd_mf
import nn
import random

def load_mf_embeds():
    user_vec = pickle.load(open("mf_emeddings/user_matrix", "rb" ))
    item_vec = pickle.load(open("mf_emeddings/item_matrix", "rb" ))
    
    return user_vec, item_vec

def load_nn_embeds():
    users = pickle.load(open("models/user_embeds", "rb" ))
    items = pickle.load(open("models/item_embeds", "rb" ))
    
    return users.cpu().weight.detach().numpy(), np.array(items.cpu().weight.detach().numpy())

def get_n_closest(in_matrix, i, n = 5):
    search_vec = in_matrix[i] # get value to be compared
    ret_matrix = cKDTree(in_matrix).query(search_vec, k = n + 1)
    return ret_matrix[0][1::], ret_matrix[1][1::] # remove most similar entry i.e. itself
    

def content_based(use_nn = True):
    user_vec, item_vec = load_nn_embeds() if use_nn else load_mf_embeds()
    
    movies = data.get_data_raw("ml-latest-small/movies.csv").to_numpy()
    
    for i in range(10):
        n_closest = get_n_closest(item_vec, i)
        recommendations = movies[n_closest[1]]
        print("For: {}\n".format(movies[i][1]))
        print("{}\n".format(recommendations))

def compare_preds(u_range = 10, i_range= 10, mf_index = True): #find difference between predicted rankings of movies generated by each method
    diff_array = np.zeros(u_range)
    for u_id in range(u_range):
        mf_preds = sgd_mf.get_predictions(u_id, 0, False)
        nn_preds = nn.get_predictions(u_id, 0, False)
        
        if mf_index:
            index, query = mf_preds[:,0], nn_preds[:,0]
        else:
            index, query = nn_preds[:,0], mf_preds[:,0]
            
        diff_sum = 0
        for i in range(i_range):
            m_id = index[i]
            q_index = np.where(query == m_id)[0][0]
            #print("Index # {} is Query # {}".format(i, q_index))
            diff_sum += abs(q_index - i)
        
        avg = diff_sum / i_range
        diff_array[u_id] = avg
        print("User {} Average difference in rank is {}".format(u_id, round(avg, 2)))
    print("Average difference: {}, List Range: {}".format(round(diff_array.mean(), 2), len(index)))
    
def compare_preds_random(u_range = 10, i_range = 10, mf_index = True):
    diff_array = np.zeros(u_range)
    user_count, item_count = data.get_data("ml-latest-small/ratings.csv").shape
    for i, u_id in enumerate(random.sample(range(user_count), u_range)):
        mf_preds = sgd_mf.get_predictions(u_id, 0, False)
        nn_preds = nn.get_predictions(u_id, 0, False)
        
        if mf_index:
            index, query = mf_preds[:,0], nn_preds[:,0]
        else:
            index, query = nn_preds[:,0], mf_preds[:,0]
            
        diff_sum = 0
        for i_id in random.sample(range(index.shape[0]), min(i_range, index.shape[0])):
            m_id = index[i_id]
            q_index = np.where(query == m_id)[0][0]
            diff_sum += abs(q_index - i_id)
        
        avg = diff_sum / i_range
        diff_array[i] = avg
        print("User {} Average difference in rank is {}".format(u_id, round(avg, 2)))
    print("Average difference: {}, Item Range: {}".format(round(diff_array.mean(), 2), item_count))
    
#compare_preds(10, 10, mf_index = False)
compare_preds_random(20, 20, mf_index = False)
#content_based()